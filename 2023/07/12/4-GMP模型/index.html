<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Golang | GMP模型 · shixiaocaia</title><meta name="description" content="参考资料

小徐先生的编程世界——Golang GMP 原理
刘丹冰博客


进程、线程、协程进程进程是运行起来的可执行程序，运行一个程序会创建一个或者多个进程。

创建进程，需要分配栈区、文件映射区等空间，所以说进程是资源分配的最小单位
每个进程有自己的独立地址空间，不与其他进程分享，但是进程间的"><meta name="og:description" content="参考资料

小徐先生的编程世界——Golang GMP 原理
刘丹冰博客


进程、线程、协程进程进程是运行起来的可执行程序，运行一个程序会创建一个或者多个进程。

创建进程，需要分配栈区、文件映射区等空间，所以说进程是资源分配的最小单位
每个进程有自己的独立地址空间，不与其他进程分享，但是进程间的"><meta name="twitter:site" content="shixiaocaia"><meta name="twitter:title" content="Golang | GMP模型"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">OutAtSea</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">是小菜啊</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li><a href="/about/index.html">About</a></li><li class="soc"><a href="https://github.com/shixiaocaia" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a><a href="https://shixiaocaia.github.io/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="https://shixiaocaia.github.io" rel="noopener noreferrer">shixiaocaia</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Golang | GMP模型</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2023-07-12</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/golang/" title="golang">golang</a><span>&nbsp;</span></span></p><p class="post-abstract"><blockquote>
<p>参考资料</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jIWe3nMP6yiuXeBQgmePDg">小徐先生的编程世界——Golang GMP 原理</a></li>
<li><a target="_blank" rel="noopener" href="https://learnku.com/articles/41728">刘丹冰博客</a></li>
</ol>
</blockquote>
<h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是运行起来的可执行程序，运行一个程序会创建一个或者多个进程。</p>
<ul>
<li>创建进程，需要分配栈区、文件映射区等空间，所以说进程是资源分配的最小单位</li>
<li>每个进程有自己的独立地址空间，不与其他进程分享，但是进程间的线程彼此共享同一个虚拟地址空间</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>通常语义下，指的是内核级的线程。</p>
<ul>
<li><p>是操作系统调度的基本单位</p>
</li>
<li><p>创建、销毁、调度由内核完成，cpu需要在内核态和用户态之间切换</p>
</li>
<li><p>可充分利用多核、实现并行</p>
</li>
</ul>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是线程的子集，是用户态线程。</p>
<ul>
<li>与线程存在映射关系，将线程资源进一步划分，看成M：1关系</li>
<li>创建、销毁、调度由用户态完成，对内核透明</li>
<li>从属于同一个内核级线程，无法并行；一个协程阻塞会导致从属同一个线程的所有协程无法执行<ul>
<li>发生阻塞时，对于操作系统来说看成是一个线程发生阻塞，无法察觉是一个协程阻塞</li>
<li>线程是操作系统调度的最小单元，协程只能做到并发，无法实现并行</li>
</ul>
</li>
</ul>
<p>协程与线程的区别：</p>
<ul>
<li>协程相比线程来说更小，只有2k大小，可以允许更多的协程来实现高并发</li>
<li>协程的上下文切换不需要经过用户态到内核态的转换，且保存的寄存器值更少，上下文切换成本小，效率高</li>
<li>通过语言层面的内置协程调度器，利用多个线程实现了协程并行</li>
</ul>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>goroutine是从普通的coroutine演变过来的，做了如下优化：</p>
<ul>
<li>通过在中间增加了调度器，实现协程与线程存在映射关系，为 M：N</li>
<li>通过设置多个调度器利用多个线程，实现协程并行</li>
<li>通过调度器的斡旋，实现和线程间的动态绑定和灵活调度</li>
<li>栈空间大小可动态扩缩，因地制宜</li>
</ul>
<h2 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h2><p>GMP是go语言协程调度模型，其由协程goroutine + 内核线程machine + 逻辑处理器processor 构成，通过调度器P将可执行的协程G放到对应的工作线程M上调度执行。</p>
<p><img src="/../images/f0499e91-cfd4-4626-bce4-f10550651190.png" alt="f0499e91-cfd4-4626-bce4-f10550651190"></p>
<h3 id="具体构成"><a href="#具体构成" class="headerlink" title="具体构成"></a>具体构成</h3><ul>
<li><p>g &#x3D; goroutine，是golang对协程的抽象</p>
<ul>
<li>g 有自己的运行栈、状态、以及执行的任务函数（用户通过 go func 指定）</li>
<li>g 需要绑定到 p 才能执行，在 g 的视角中，p 就是它的 cpu</li>
</ul>
</li>
<li><p>p &#x3D; processor，是 golang 中的调度器</p>
<ul>
<li>对 g 而言，p 是其 cpu，g 只有被 p 调度，才得以执行</li>
<li>对 m 而言，p 是其执行代理，为其提供必要信息的同时（可执行的 g、内存分配情况等），并隐藏了繁杂的调度细节</li>
<li>p 的数量决定了 g 最大并行数量，通过 GOMAXPROCS 进行设定（超过 CPU 核数时无意义），任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行</li>
</ul>
</li>
<li><p>m &#x3D;  machine，是 golang 中对线程的抽象</p>
<ul>
<li>m 不直接执行 g，而是先和 p 绑定，由其实现代理</li>
<li>借由 p 的存在，m 无需和 g 绑死，也无需记录 g 的状态信息，因此 g 在全生命周期中可以实现跨 m 执行</li>
<li>go程序启动时，会设置 M 的最大数量，默认 10000。 但是内核很难支持这么多的线程数，所以这个限制可以忽略</li>
<li>当一个m发生阻塞，去寻找空闲的M，如果没有会创建新的m去接管之前的P</li>
</ul>
</li>
<li><p>全局队列：存放等待运行的 G，本地存放不下的G也会放到这里</p>
</li>
<li><p>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列</p>
</li>
<li><p>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个</p>
</li>
<li><p>g0：是特殊的调度协程，不用于执行用户函数，负责执行g之间的切换调度，每个M有一个对应的g0</p>
</li>
</ul>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ul>
<li>M调度G前需要和P绑定，优先取P本地队列，其次取全局队列，最后取wait队列（为io阻塞就绪态goroutine队列）；这样的好处是，优先取本地队列时，可以接近于无锁化，减少全局锁竞争。</li>
<li>为防止不同P的闲忙差异过大，设立work-stealing机制，本地队列为空的P可以尝试从其他P本地队列偷取一半的G补充到自身队列，实现负载均衡，防止不同P的闲忙差异过大。<ul>
<li>由于存在窃取情况，所以本地队列中还是需要考虑加锁，但是相比全局队列所有P都可能访问，发生概率很低，接近无锁化情况</li>
<li>全局队列当中，所有P都可能访问，所以需要加锁避免并发问题</li>
</ul>
</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> g <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ...</span>
    m         <span class="token operator">*</span>m      
    <span class="token comment" spellcheck="true">// ...</span>
    sched     gobuf
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>m对应后续绑定的执行线程，可以进行动态调整</p>
<p><img src="/../images/640.png" alt="图片"></p>
<p>整个goroutine生命周期包括如上几个状态：</p>
<ul>
<li>当goroutine创建时处于gidle，完成初始化后进入gdead状态</li>
<li>当g可以执行，等待调度进入grunnable状态</li>
<li>成功被调度，进入grunning，执行逻辑<ul>
<li>当代码逻辑涉及内核态操作，会进入系统调用的状态，阻塞等待，完成后又进入可执行等待调度的状态</li>
<li>有时可能涉及并发未获取到锁，进入gwaiting阻塞等待</li>
</ul>
</li>
<li>g成功调度执行完，进入gdead状态</li>
</ul>
<pre class="line-numbers language-c"><code class="language-c">type m <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    g0      <span class="token operator">*</span>g     <span class="token comment" spellcheck="true">// goroutine with scheduling stack</span>
    <span class="token comment" spellcheck="true">// ...</span>
    tls           <span class="token punctuation">[</span>tlsSlots<span class="token punctuation">]</span>uintptr <span class="token comment" spellcheck="true">// thread-local storage (for x86 extern register)</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>对于一个m，包含了特殊的调度协程go，不用于执行用户函数，负责执行 g 之间的切换调度. 与 m 的关系为 1:1</li>
<li>tls：thread-local storage，线程本地存储，存储内容只对当前线程可见. 线程本地存储的是 m.tls 的地址，m.tls[0] 存储的是当前运行的 g，因此线程可以通过 g 找到当前的 m、p、g0 等信息。</li>
</ul>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> p <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ...</span>
    runqhead <span class="token builtin">uint32</span>
    runqtail <span class="token builtin">uint32</span>
    runq     <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span>guintptr
    
    runnext guintptr
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>runq对应一个P的本地队列，是一个双向队列</li>
<li>runqhead：队列头部</li>
<li>runqtail：队列尾部</li>
<li>runnext：下一个可执行的 goroutine</li>
</ul>
<pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> schedt <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ...</span>
    lock mutex
    <span class="token comment" spellcheck="true">// ...</span>
    runq     gQueue
    runqsize <span class="token builtin">int32</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>sched 是全局 goroutine 队列的封装：</p>
<ul>
<li><p>lock：一把操作全局队列时使用的锁；</p>
</li>
<li><p>runq：全局 goroutine 队列；</p>
</li>
<li><p>runqsize：全局 goroutine 队列的容量.</p>
</li>
</ul>
<h2 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h2><h3 id="两种goroutine"><a href="#两种goroutine" class="headerlink" title="两种goroutine"></a>两种goroutine</h3><p>goroutine主要分为两类：</p>
<ul>
<li>负责调度普通 g 的 g0，执行固定的调度流程，与 m 的关系为一对一</li>
<li>负责执行用户函数的普通 g</li>
</ul>
<p>m 通过 p 调度执行的 goroutine 永远在普通 g 和 g0 之间进行切换，当 g0 找到可执行的 g 时，会调用 gogo 方法，调度 g 执行用户定义的任务；当 g 需要主动让渡或被动调度时，会触发 mcall 方法，将执行权重新交还给 g0。</p>
<h3 id="调度类型"><a href="#调度类型" class="headerlink" title="调度类型"></a>调度类型</h3><p><img src="/../images/gmp1.png" alt="图片"></p>
<ul>
<li>主动调度<ul>
<li>用户主动使用<code>Gosched</code>让出当前P的执行权，g投递到全局队列当中</li>
<li>此时g0重新获取到执行权，获取可执行的下一个g</li>
</ul>
</li>
<li>被动调度<ul>
<li>因当前不满足某种执行条件，g 可能会陷入阻塞态无法被调度，直到关注的条件达成后，g才从阻塞中被唤醒，重新进入可执行队列等待被调度。常见阻塞方式：加锁、有缓存的通道阻塞等待。</li>
<li>当一个g需要进入被动调度状态，通过gopark陷入gwaiting状态，底层通过mcall将执行权归还给g0</li>
<li>同时当前p和g进行解绑，g0获取下一个可以执行调度g</li>
<li>当g完成阻塞时，可以被唤醒时，通过某个p的g0调度到，将g尝试加入到主动唤醒操作（goready）的P本地队列当中</li>
</ul>
</li>
<li>正常调度<ul>
<li>g 中的执行任务已完成，g0 会将当前 g 置为死亡状态，发起新一轮调度</li>
</ul>
</li>
<li>抢占调度<ul>
<li>前面的操作，主要通过g0在用户态范围进行切换。抢占主要由一个全局监控者g完成，将某个执行系统调用时间过长的g与当前p进行解绑</li>
<li>某个g发起内核切换，由线程身份进入内核态发起系统调用，所以此时m由于系统调用陷入僵持态，此时对应m的g0无法得到执行，所以需要一个全局g来完成操作</li>
<li>全局g会把P抽离出去，尝试与其他m进行绑定执行，不影响之前的m和g，把P拿出去继续调度执行</li>
<li>这里发生抢占调度时机，主要判断当前是否为空闲状态，一般本地队列有需要执行的g，或者没有空闲的p和m时，处于忙碌状态需要考虑抢占调度，也要看发生系统调用的时长是否过长</li>
</ul>
</li>
</ul>
<h3 id="宏观调度"><a href="#宏观调度" class="headerlink" title="宏观调度"></a>宏观调度</h3><p><img src="/../images/gmp2.png" alt="图片"></p>
<p>gmp一个从g0–&gt;g–&gt;过程，主要包含以下几个步骤：</p>
<ul>
<li>g0 执行 schedule() 函数，寻找到用于执行的 g</li>
<li>g0 执行 execute() 方法，更新当前 g、p 的状态信息，并调用 gogo() 方法，将执行权交给 g</li>
<li>g 因主动让渡( gosche_m() )、被动调度( park_m() )、正常结束( goexit0() )等原因，调用 m_call 函数，执行权重新回到 g0 手中</li>
<li>g0 执行 schedule() 函数，开启新一轮循环</li>
</ul>
<h3 id="findRunnable"><a href="#findRunnable" class="headerlink" title="findRunnable"></a>findRunnable</h3><p><img src="/../images/gmp3.png" alt="图片"></p>
<p>寻找可执行g进行调度额过程：</p>
<ul>
<li>为了避免一直执行本地队列，导致全局队列g的搁置。p 每执行 61 次调度，会从全局队列中获取一个 goroutine 进行执行。同时这其中涉及一些系统调用，比如gc等，所以实际会在61之前从全局中获取。</li>
<li>首先尝试从 p 本地队列中获取一个可执行的 goroutine，并且这个过程需要加锁<ul>
<li>由于存在work-stealing机制，需要加锁保正并发安全。窃取动作不会频繁发生，获取锁的概率很高，接近无锁化操作。</li>
</ul>
</li>
<li>如果本地队列没有可执行的g，从全局队列中获取</li>
<li>倘若本地队列和全局队列都没有 g，则会获取准备就绪的IO协程</li>
<li>如果上述还没有，尝试从其他P的本地队列，偷取一半的g<ul>
<li>一共会发起四次尝试，某一次成功即返回</li>
<li>偷取过程中会随机遍历P的起点位置，跳跃遍历，保证公平性</li>
<li>窃取目标P本地队列的一半，移动其头指针更新被偷取的队列信息</li>
</ul>
</li>
</ul>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><ul>
<li><p>更新 g 的状态信息，建立 g 与 m 之间的绑定关系</p>
</li>
<li><p>更新 p 的总调度次数</p>
</li>
<li><p>调用 gogo 方法，执行 goroutine 中的任务</p>
</li>
</ul>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://shixiaocaia.github.io/2023/07/12/4-GMP模型/%20shixiaocaia%20Golang | GMP模型"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2023/09/03/1-wsl+golang/" title="WSL中配置golang环境"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: WSL中配置golang环境</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2023/07/12/5-MQ/" title="消息队列">Next post: 消息队列&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="https://shixiaocaia.github.io" rel="noopener noreferrer">shixiaocaia</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>